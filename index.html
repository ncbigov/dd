<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Banana Catch Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Light
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(5, 5, 5);
    scene.add(light);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Banana (Player)
    const bananaGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const bananaMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
    const playerBanana = new THREE.Mesh(bananaGeometry, bananaMaterial);
    playerBanana.position.set(0, 1, 0);
    scene.add(playerBanana);

    // Falling Bananas
    const fallingBananas = [];
    const bananaCount = 20;

    for (let i = 0; i < bananaCount; i++) {
      const banana = new THREE.Mesh(
        bananaGeometry,
        bananaMaterial
      );
      banana.position.set(
        (Math.random() - 0.5) * 10,
        10,
        (Math.random() - 0.5) * 10
      );
      scene.add(banana);
      fallingBananas.push(banana);
    }

    // Controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    document.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - previousMousePosition.x;
        const dy = e.clientY - previousMousePosition.y;
        playerBanana.position.x += dx * 0.01;
        playerBanana.position.z += dy * 0.01;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    // Game Loop
    let score = 0;
    const scoreText = document.createElement('div');
    scoreText.style.position = 'absolute';
    scoreText.style.top = '10px';
    scoreText.style.left = '10px';
    scoreText.style.color = 'white';
    scoreText.style.fontSize = '24px';
    document.body.appendChild(scoreText);

    function animate() {
      requestAnimationFrame(animate);

      // Move falling bananas
      fallingBananas.forEach(banana => {
        banana.position.y -= 0.1;
        if (banana.position.y < -5) {
          banana.position.y = 10;
          banana.position.x = (Math.random() - 0.5) * 10;
          banana.position.z = (Math.random() - 0.5) * 10;
        }
      });

      // Collision detection
      fallingBananas.forEach(banana => {
        const distance = playerBanana.position.distanceTo(banana.position);
        if (distance < 1.5) {
          score++;
          scoreText.textContent = `Score: ${score}`;
          banana.position.y = 10;
          banana.position.x = (Math.random() - 0.5) * 10;
          banana.position.z = (Math.random() - 0.5) * 10;
        }
      });

      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
